<!doctype html>
<html lang="en">
  <head>
    <title>MtG Tabletop Simulator Deck Builder</title>
    <link rel="stylesheet" href="/beta/static/stylesheet.css">
  </head>
  <body>
    <script type="text/javascript" src="/beta/static/index.js"></script>
    <script type="text/javascript">
(function () {
  "use strict";

  const socketURL = (function () {
    let socketProto;
    switch (window.location.protocol) {
    case "http:":
      socketProto = "ws:";
      break;
    case "https:":
      socketProto = "wss:";
      break;
    default:
      throw new Error("Unknown protocol " + window.location.protocol);
    }
    return socketProto + "//" + window.location.host + "/ws/";
  })();

  const app = Elm.Main.init({
    flags: { socketURL: socketURL },
  });

  const sendSocketCommand = (function () {
    const sockets = new Map();
    const sendQueues = new Map();
    const socketAttempts = new Map();

    function inner (value) {
      if (value.cmd === "connect") {
        console.log("Connecting websocket", value.name, "to address", value.address, "with protocol", value.protocol);
        const socket = new WebSocket(value.address, value.protocol);
        socket.onclose = function (event) {
          console.log("Got close event for socket \"" + value.name + "\":", event);
          if (!sockets.has(value.name)) {
            // This was intentionally closed.
            return;
          }
          const attempts = socketAttempts.get(value.name) || 1;
          socketAttempts.set(value.name, attempts + 1);
          const delaySeconds = attempts > 0 ? Math.pow(1.5, self._attempts - 1) : 0;
          if (delaySeconds > 0) {
            console.log("Reconnecting WebSocket \"" + value.name + "\" after " + delaySeconds + " seconds");
            window.setTimeout(() => sendSocketCommand(value), delaySeconds * 1000.0);
          } else {
            sendSocketCommand(value);
          }
        };
        socket.onopen = function (event) {
          console.log("Got open event for socket \"" + value.name + "\":", event);
          socketAttempts.delete(value.name);
          const pendingMsgs = sendQueues.get(value.name);
          while (pendingMsgs.length > 0) {
            const pendingMsg = pendingMsgs.shift();
            socket.send(pendingMsg);
          }
        };
        socket.onmessage = function (event) {
          app.ports.wsToElmPort.send({
            name: value.name,
            msg: "data",
            data: event.data,
          });
        };
        sockets.set(value.name, socket);
      } else if (value.cmd === "send") {
        const socket = sockets.get(value.name);
        if (socket) {
          socket.send(value.content);
        } else {
          if (!sendQueues.has(value.name)) {
            sendQueues.set(value.name, []);
          }
          const queue = sendQueues.get(value.name);
          queue.push(value.content);
        }
      } else if (value.cmd === "close") {
        const socket = sockets.get(value.name);
        sockets.delete(value.name);
        if (socket) {
          socket.close();
        }
      } else {
        console.error("Got unexpected command name from websocket port:", value.cmd);
      }
    }
    return inner;
  })();
  app.ports.wsFromElmPort.subscribe(sendSocketCommand);
  // app.ports.saveJsonPort.subscribe(function (value) {
  //   const filename = value.filename;
  //   const json = JSON.stringify(value.jsonValue);
  //   const properties = {type: "application/json"};

  //   let file;
  //   try {
  //     file = new File(json, filename, properties);
  //   } catch (e) {
  //     file = new Blob(json, properties);
  //   }
  //   const url = URL.createObjectURL(file);
  //   const a = document.createElement("a");
  //   a.setAttribute("target", "_blank");
  //   a.setAttribute("download", "");
  //   document.appendChild(a);
  //   a.href = url;
  //   setTimeout(function () {
  //     document.removeChild(a);
  //   }, 5000);
  // });
})();
    </script>
</html>
